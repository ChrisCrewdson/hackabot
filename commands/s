#!/usr/bin/perl

##HACKABOT_HELP##
# Apply a find/replace regex to a message (last 50 lines only)
# !s/find/replace/[gi]         (g will match other people too)
##HACKABOT_HELP##

use strict;
use DBI;
use Time::localtime;

# specify your database connection parameters here
my $dbhost = 'db0.osuosl.org';
my $dbname = 'manatee-data';
my $dbuser = 'manatee-data';
my $dbpass = 'AvjQAc91hH';

sub replace {
	my $nick = shift;
	my $chan = shift;
	my $find = shift;
	my $replace = shift;
	my $option = shift;
	my ($dbh, $sth);
	my $row;
	my $ret = "$nick: Sorry, I can't match the expression '$find'.\n";

	$dbh = DBI->connect("DBI:mysql:$dbname:$dbhost", $dbuser, $dbpass, { PrintError => 1 });
	if (!$dbh) {
		die "see: Failed to connect to database\n";
	}
	
	my $qnick = $dbh->quote($nick);
	$chan = $dbh->quote($chan);

	for (my $i = 0; $i < 50; $i++) {
		if (defined $option and $option =~ /g/) {
			$sth = $dbh->prepare("SELECT id, text, nick, type FROM log WHERE chan = $chan AND ( type = 'msg' OR type = 'action' ) ORDER BY id DESC LIMIT 1 OFFSET $i");
		} else {
			$sth = $dbh->prepare("SELECT id, text, nick, type FROM log WHERE nick = $qnick AND chan = $chan AND ( type = 'msg' OR type = 'action' ) ORDER BY id DESC LIMIT 1 OFFSET $i");
		}
		$sth->execute();
		if ($row = $sth->fetchrow_hashref()) {
			if ($row->{'text'} =~ m/^!/) {
				$sth->finish();
				next;
			}
			if ($row->{'text'} =~ m/$find/) {
				my $text = $row->{'text'};
				$replace =~ s/(?<!\\)[\\\$]([1-9])/__REPLACEMENT_$1__/g;
				
				my @match;
				if (defined $option and $option =~ /i/) {
					$text =~ s/$find/$replace/gi;
					for (my $j = 1; $j <= 9; $j++) {
						no strict 'refs';
						$match[$j] = ${"$j"};
					}
				}
				else {
					$text =~ s/$find/$replace/g;
					for (my $j = 1; $j <= 9; $j++) {
						no strict 'refs';
						$match[$j] = ${"$j"};
					}
				}
				
				for (my $j = 1; $j <= 9; $j++) {
					$text =~ s/__REPLACEMENT_${j}__/$match[$j]/g;
				}
				
				if ($row->{'type'} eq "msg") {
					$ret = "$row->{'nick'} actually meant: $text";
				}
				elsif ($row->{'type'} eq "action") {
					$ret = "correction: * $row->{'nick'} $text";
				}
				else {
					$ret = "ERROR: unknown type: $row->{'type'}.";
				}
				$sth->finish();
				last;
			}
		}
		else {
			$sth->finish();
			last;
		}
		$sth->finish();
	}

	$dbh->disconnect;

	return $ret;
}

my ($nick, $chan, $find, $replace, $arg, $option);
while (<>) {
	if (/^nick\s*(\S*)/) {
		$nick = $1;
	}
	if (/^to\s*(\S*)/) {
		$chan = $1;
	}
	elsif (/^msg\s*\/([^\\]?[^\/]*)\/([^\\]?[^\/]*)\/([ig]*)/) {
		$find = $1;
		$replace = $2;
		$option = $3;
	}
}

if (defined $nick and defined $chan and defined $find and defined $replace) {
	print "send " . replace($nick, $chan, $find, $replace, $option);
}
else {
	die "s: malformed request\n";
}
