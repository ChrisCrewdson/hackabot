#!/usr/bin/perl -w
# Hackabot -- Version 2

package Hackabot;

use strict;
use threads;
use threads::shared;
use Thread::Serialize;
use IPC::Open2;
use Socket;
use Net::IRC;
STDOUT->autoflush(1);

sub new {
	my $class = shift;
	my $CONFIG = shift;

	my $f1 = freeze({});
	my $f2 = freeze({});
	share($f1);
	share($f2);
	
	my $self = {};
	$self->{'CONFIG'}	= $CONFIG;
	$self->{'irc'}		= undef;
	$self->{'conn'}		= undef;
	$self->{'chandb'}	= \$f1;
	$self->{'userdb'}	= \$f2;
	
	bless($self, $class);
	return $self;
}

sub start {
	my $self = shift;

	return threads->new(\&run,$self);
}

sub startconn {
	my $self = shift;
	my $CONFIG = $self->{'CONFIG'};
	
	# Start up the IRC connection.
	my $irc = new Net::IRC;

	$self->pmsg("Connecting to IRC server $CONFIG->{'server'}...");
	my $conn = $irc->newconn(
			Server   => ($CONFIG->{'server'}),
			Nick     => $CONFIG->{'nick'},
			Ircname  => $CONFIG->{'name'})
		or $self->perr("Can't connect to IRC server.");
	$conn->{'CONFIG'} = $CONFIG;
	$conn->{'bot'} = $self;
	
	$self->{'irc'} = $irc;
	$self->{'conn'} = $conn;
}

sub run {
	my $self = shift;
	my $CONFIG = $self->{'CONFIG'};

	# Start up the IRC connection.
	my $irc = new Net::IRC;

	$self->pmsg("Connecting to IRC server $CONFIG->{'server'}...");
	my $conn = $irc->newconn(
			Server   => ($CONFIG->{'server'}),
			Nick     => $CONFIG->{'nick'},
			Ircname  => $CONFIG->{'name'})
		or $self->perr("Can't connect to IRC server.");

	$conn->{'CONFIG'} = $CONFIG;
	$conn->{'bot'} = $self;
	$self->{'irc'} = $irc;
	$self->{'conn'} = $conn;
	
	# fire off the socket server
	my $t = threads->new(\&server,$self);
	$t->detach();

	$conn->add_handler('msg',    \&on_msg);
	$conn->add_handler('public', \&on_public);
	$conn->add_handler('disconnect', \&on_disconnect);
	$conn->add_handler(376, \&on_connect);
	$conn->add_handler(433, \&on_nick_taken);
	$conn->add_handler(353, \&on_names);
	
	$self->pmsg("Starting irc event loop...");
	
	$irc->start();
	#while (1) {
	#	$irc->do_one_loop();
	#	extcheck($CONFIG, $extfifos, $conn);
	#}
}

# Run the server socket (should be forked off as this won't return)
sub server {
	my $self = shift;
	my $CONFIG = $self->{'CONFIG'};

	$self->pmsg("Creating control socket...");
	socket(SOCK,PF_UNIX,SOCK_STREAM,0) 
		|| $self-perr("socket: $!") && return 0;
	unlink($CONFIG->{'socket'});
	bind(SOCK, sockaddr_un($CONFIG->{'socket'})) 
		|| $self->perr("bind: $!") && return 0;
	listen(SOCK, 10);

	while (1) {
		my $paddr = accept(SOCK_C, SOCK);
		next if not $paddr;
		my $t = threads->new(sub {
			SOCK_C->autoflush(1);
			$self->pmsg("New control socket connection.");
		
			$self->runaction(*SOCK_C,1);
		
			$self->pmsg("Closing control socket connection.");
			close SOCK_C;
		});
		$t->detach;
		close SOCK_C;
	}
}

# Wrappers and helpers to manage chandb and userdb
sub chan_join {
	my $self = shift;
	my $chan = shift;
	my $passwd = shift;

	my $chandb;
	$self->pmsg("joining $chan");
	{
		lock $self->{'chandb'};
		$chandb = thaw(${$self->{'chandb'}});
		$chandb->{$chan} = {};
		$self->{'chandb'} = freeze($chandb)
	}
	$self->{'conn'}->join($chan, defined $passwd?$passwd:'');
}

sub chan_get_names {
	my $self = shift;
	my $chan = shift;

	my $chandb;
	{
		lock $self->{'chandb'};
		$chandb = thaw($self->{'chandb'});
	}
	if (!defined($chandb->{$chan})) {
		$self->perr("chan_get_names: $chan does not exist.");
		return undef;
	}
	return keys %{$chandb->{$chan}};
}

sub chan_add_names {
	my $self = shift;
	my $chan = shift;
	my @names = @_;

	lock $self->{'chandb'};
	my $chandb = thaw($self->{'chandb'});
	
	if (!defined($chandb->{$chan})) {
		$self->perr("chan_get_names: $chan does not exist.");
		return undef;
	}
	for (@names) {
		my $op = 0;
		if (s/^@//) {
			$op = 1;
		}
		$chandb->{$chan}->{$_} = {};
		$chandb->{$chan}->{$_}{'op'} = $op;
	}
	$self->{'chandb'} = freeze($chandb)
}

sub chan_reset_names {
	my $self = shift;
	my $chan = shift;

	lock $self->{'chandb'};
	my $chandb = thaw($self->{'chandb'});
	$chandb->{$chan} = {};
	$self->{'chandb'} = freeze($chandb);
	$self->{'conn'}->names($chan);
}

# Process and run some requests
sub runaction {
	my $self = shift;
	my $CHILD = shift;
	my $rw = shift;
	my $to = shift;

	my $conn = $self->{'conn'};
	my $ret = "ok";
	my $mode = "cmd";
	while (<$CHILD>) {
		# Read in and run commands
		if ($mode eq "sendnext" and defined $to) {
			$conn->privmsg($to, "$_\n");
		}
		elsif (/^sendnext/ and defined $to) {
			$mode = "sendnext";
		}
		elsif (/^send\s+(.+)$/ and defined $to) {
			$conn->privmsg($to, "$1\n");
		}
		elsif (/^notice\s+(.+)$/ and defined $to) {
			$conn->notice($to, "$1\n");
		}
		elsif (/^me\s+(.+)$/ and defined $to) {
			$conn->me($to, "$1\n");
		}
		elsif (/^to\s+(\S+)$/) {
			$to = $1;
		}
		elsif (/^nick\s+(\S+)$/) {
			$conn->nick($1);
		}
		elsif (/^join\s+(\S+)\s*(\S*)$/) {
			$conn->join($1, $2 ? $2 : '');
		}
		elsif (/^part\s+(.+)/) {
			$conn->part(split(/\s/,$1));
		}
		elsif (/^quit\s+(\S*.*)$/) {
			$conn->quit(defined $1 ? $1 : 'Bye Bye!');
		}
		elsif ($rw && /^names\s+(\S+.*)$/) {
			print $CHILD join(" ",chan_get_names($1));
		}
		#elsif ($rw && /^who\s+(\S+.*)$/) {
		#	#print $CHILD $ircconn->who(split(/\s/,$1));
		#}
		elsif (/^nocmd/) {
			$ret = "nocmd";
		}
		elsif (/^nohook/) {
			$ret = "nohook";
		}
		elsif (/^noall/) {
			$ret = "noall";
		}
		else {
			$self->pmsg("Unknown cmdline: $_");
		}
	}
	return $ret;
}

# Run a !cmd line
sub runcmd {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $cmd = shift;
	my $txt = shift;
	
	my $CONFIG = $self->{'CONFIG'};
	my $exe = "/$CONFIG->{'directory'}/$CONFIG->{'commands'}/$cmd";

	if ( not $cmd =~ /^[^\.]/ or not -x "$exe" ) {
		if ( $CONFIG->{'verbose'} ) {
			$self->{'conn'}->privmsg($to, "No such command.\n");	
		}
		return;
	}

	$self->runmod($event, $to, $exe, $txt);
	return "ok";
}

# Run a set of hooks
sub runhook {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $hook = shift;
	my $txt = shift;
	
	my $CONFIG = $self->{'CONFIG'};
	my $dir = "/$CONFIG->{'directory'}/$CONFIG->{'hooks'}/$hook";
	
	my $ret = "ok";
	if ( -d $dir ) {
		my @hooks;
		opendir(HOOKDIR, $dir);
		while ($_ = readdir(HOOKDIR)) {
			push(@hooks, $_);
		}
		closedir(HOOKDIR);
		foreach $_ (sort @hooks) {
			if (/^[^\.]/ and -x "$dir/$_") {
				my $r = $self->runmod($event, $to, "$dir/$_", $txt);
				if ($r eq "nocmd" or $r eq "noall") {
					$ret = "nocmd";
				}
				if ($r eq "nohook" or $r eq "noall") {
					last;
				}
			}
		}
	}
	return $ret;
}

# A safer replacement for `$cmd` commands
# plus some bangs and wizzing amazingness
sub runmod {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $cmd = shift;
	my $txt = shift;
	
	if (not -x "/$cmd") {
		$self->perr("Error: no such module /$cmd");	
		return "ok";
	}

	local(*FROM_CHILD,*TO_CHILD);
	my $child = open2(*FROM_CHILD,*TO_CHILD,"/$cmd", @{[]}) ||
		$self->perr("run_mod: Cannot fork and run /$cmd");

	

	print TO_CHILD "type $event->{'type'}\n";
	if (defined $event->{'nick'}) {
		print TO_CHILD "nick $event->{'nick'}\n";
	}
	if (defined $event->{'user'}) {
		print TO_CHILD "user $event->{'user'}\n";
	}
	if (defined $event->{'host'}) {
		print TO_CHILD "host $event->{'host'}\n";
	}
	if (defined $to) {
		print TO_CHILD "to $to\n";
	}
	if (defined $txt) {
		print TO_CHILD "msg $txt\n";
	}
	close TO_CHILD;

	my $ret = $self->runaction(*FROM_CHILD,0,$to);

	close FROM_CHILD;
	waitpid($child,0);
	return $ret;
}

# What to do when the bot successfully connects.
sub on_connect {
	my $self = shift;
	my $CONFIG = $self->{'CONFIG'};
	
	$self->{'bot'}->pmsg("Connected!");
	sleep 1;
	foreach (@{$CONFIG->{'automsg'}}) {
		$self->{'bot'}->pmsg("sending message to $_->{'to'}");
		$self->privmsg($_->{'to'}, $_->{'content'});
	}
	sleep 1;
	foreach (@{$CONFIG->{'autojoin'}}) {
		$self->{'bot'}->chan_join($_->{'chan'}, $_->{'password'});
		if (defined $_->{'content'}) {
			$self->privmsg($_->{'chan'}, $_->{'content'});
		}
	}
}

# What to do when we receive a private PRIVMSG.
sub on_msg {
	my ($self, $event) = @_;
	my $to = $event->nick;
	my ($msg) = ($event->args);

	my $t = threads->new(sub {
		my $r = $self->{'bot'}->runhook($event, $to, "private", $msg);
		if ($r ne "nocmd" and $msg =~ /^!([^\s\/]*)\s*(.*)/) {
    			my $cmd = $1;
			my $txt = $2;

			$self->{'bot'}->runcmd($event, $to, $cmd, $txt);
		}
	});
	$t->detach;
}

# What to do when we receive channel text.
sub on_public {
	my ($self, $event) = @_;
	my $to = ${$event->to}[0];
	my ($msg) = ($event->args);

	my $t = threads->new(sub {
		my $r = $self->{'bot'}->runhook($event, $to, "public", $msg);
		if ($r ne "nocmd" and $msg =~ /^!([^\s\/]*)\s*(.*)/) {
    			my $cmd = $1;
			my $txt = $2;

			$self->{'bot'}->runcmd($event, $to, $cmd, $txt);
		}
	});
	$t->detach;
}

# Change our nick if someone stole it.
sub on_nick_taken {
    my $self = shift;

    $self->nick($self->nick . "_");
}

sub on_names {
	my ($self, $event) = @_;
	
	$self->{'bot'}->chan_add_names($event->{'args'}->[2],
		split(/\s/,$event->{'args'}->[3]));
}

# Exit when connection is lost
sub on_disconnect {
	my ($self, $event) = @_;

	$self->{'bot'}->pmsg("Disconnected from " . $event->from() . " (" .
	      ($event->args())[0] . ").");

	#exit;	      
}

# Reconnect to the server when we die.
#sub on_disconnect {
#	my ($self, $event) = @_;
#
#	print "hackabot: Disconnected from ", $event->from(), " (",
#	      ($event->args())[0], ").";
#	      
#	sleep(60);
#	print "hackabot: Attempting to reconnect...\n";
#	
#	$self->connect();
#}

sub on_any_dump {
	my ($self, $event) = @_;

	use Data::Dumper;
	print Dumper $event;
}

sub pmsg {
	my $self = shift;
	my $msg = shift;
	return print STDOUT "hackabot[".threads->self->tid."]: $msg\n";
}

sub perr {
	my $self = shift;
	my $msg = shift;
	return print STDERR "hackabot[".threads->self->tid."]: $msg\n";
}

1;

# Main code to start it up:
package main;

use strict;
use XML::Simple;
STDOUT->autoflush(1);


my $cfgfile = shift;
if (not defined $cfgfile) {
	$cfgfile = "$ENV{'HOME'}/.hackabot.xml";
}

my $CONFIG  = XMLin($cfgfile, ForceArray => ['automsg', 'autojoin', qr/^x-/]);
$ENV{'HACKABOT_DIR'} = $CONFIG->{'directory'};
$ENV{'HACKABOT_ETC'} = "$CONFIG->{'directory'}/$CONFIG->{'etc'}";
$ENV{'HACKABOT_CMD'} = "$CONFIG->{'directory'}/$CONFIG->{'commands'}";
$ENV{'HACKABOT_SOCK'} = $CONFIG->{'socket'};

my $bot = new Hackabot($CONFIG);
$bot->pmsg("Configuration loaded, starting...");
my $tid = $bot->start();
$tid->join();

