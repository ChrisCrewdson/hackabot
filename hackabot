#!/usr/bin/perl -w
#
# An IRC BOT for the OSU Open Source Lab
#
# Copyright 2005 Michael Marineau
# Licensed under the GPLv2

# This piece is based in part on the irctest script distributed with Net::IRC

use strict;
use Socket;
use Net::IRC;
use XML::Simple;
use Data::Dumper;
use IPC::Open2;
use Socket;
use IO::Handle;
use Fcntl;
use threads;
STDOUT->autoflush(1);

my $cfgfile = shift;
if (not defined $cfgfile) {
	$cfgfile = "$ENV{'HOME'}/.hackabot.xml";
}

our $CONFIG = XMLin($cfgfile, ForceArray => ['automsg', 'autojoin', qr/^x-/]);
#print Dumper $CONFIG;
#exit;

$ENV{'HACKABOT_DIR'} = $CONFIG->{'directory'};
$ENV{'HACKABOT_ETC'} = "$CONFIG->{'directory'}/$CONFIG->{'etc'}";
$ENV{'HACKABOT_CMD'} = "$CONFIG->{'directory'}/$CONFIG->{'commands'}";
$ENV{'HACKABOT_SOCK'} = $CONFIG->{'socket'};


# Start up the IRC connection.
my $irc = new Net::IRC;

print msg("Creating connection to IRC server...");
my $conn : shared = $irc->newconn(Server   => ($CONFIG->{'server'}),
			 Nick     => $CONFIG->{'nick'},
			 Ircname  => $CONFIG->{'name'})
    or die msg("Can't connect to IRC server.");

if (defined($CONFIG->{'socket'})) {
	my $t = threads->new(\&sock_server,$conn);
	$t->detach;
}

# Run the server socket (should be forked off as this won't return)
sub sock_server {
	print msg("Creating control socket...");
	socket(SOCK,PF_UNIX,SOCK_STREAM,0) 
		|| die msg("socket: $!");
	unlink($CONFIG->{'socket'});
	bind(SOCK, sockaddr_un($CONFIG->{'socket'})) 
		|| die msg("bind: $!");
	listen(SOCK, 10);

	while (1) {
	
	my $paddr = accept(SOCK_C, SOCK);
	next if not $paddr;
	my $t = threads->new(sub {
		SOCK_C->autoflush(1);
		print msg("Opening a control socket connection.");
		
		runaction(*SOCK_C,1);
		
		print msg("Closing a control socket connection.");
		close SOCK_C;
	});
	$t->detach;
	close SOCK_C;
	
	} #while(1)
}

# What to do when the bot successfully connects.
sub on_connect {
	my $self = shift;
	
	print msg("Connected!");
	sleep 1;
	foreach (@{$CONFIG->{'automsg'}}) {
		print msg("sending message to $_->{'to'}");
		$self->privmsg($_->{'to'}, $_->{'content'});
	}
	sleep 1;
	foreach (@{$CONFIG->{'autojoin'}}) {
		print msg("joining $_->{'chan'}");
		$self->join($_->{'chan'}, defined $_->{'password'}?$_->{'password'}:'');
		if (defined $_->{'content'}) {
			$self->privmsg($_->{'chan'}, $_->{'content'});
		}
	}
}

# Process and run some requests
sub runaction {
	my $CHILD = shift;
	my $rw = shift;
	my $to = shift;

	my $ret = "ok";
	my $mode = "cmd";
	while (<$CHILD>) {
		# Read in and run commands
		if ($mode eq "sendnext" and defined $to) {
			lock($conn);
			$conn->privmsg($to, "$_\n");
		}
		elsif (/^sendnext/ and defined $to) {
			$mode = "sendnext";
		}
		elsif (/^send\s+(.+)$/ and defined $to) {
			lock($conn);
			$conn->privmsg($to, "$1\n");
		}
		elsif (/^notice\s+(.+)$/ and defined $to) {
			lock($conn);
			$conn->notice($to, "$1\n");
		}
		elsif (/^me\s+(.+)$/ and defined $to) {
			lock($conn);
			$conn->me($to, "$1\n");
		}
		elsif (/^to\s+(\S+)$/) {
			$to = $1;
		}
		elsif (/^nick\s+(\S+)$/) {
			lock($conn);
			$conn->nick($1);
		}
		elsif (/^join\s+(\S+)\s*(\S*)$/) {
			lock($conn);
			$conn->join($1, $2 ? $2 : '');
		}
		elsif (/^part\s+(.+)/) {
			lock($conn);
			$conn->part(split(/\s/,$1));
		}
		elsif (/^quit\s+(\S*.*)$/) {
			#$self->quit(defined $1 ? $1 : 'Bye');
			#lock($conn);
			$conn->quit();
		}
		elsif ($rw && /^names\s+(\S+.*)$/) {
			#$ircconn->names(split(/\s/,$1));
			#$conn->add_global_handler(353, sub {
  			#	my ($self, $event) = @_;
			#	print $CHILD @{$event->args}[4]."\n";
			#});
		}
		elsif ($rw && /^who\s+(\S+.*)$/) {
			#print $CHILD $ircconn->who(split(/\s/,$1));
		}
		elsif (/^nocmd/) {
			$ret = "nocmd";
		}
		elsif (/^nohook/) {
			$ret = "nohook";
		}
		elsif (/^noall/) {
			$ret = "noall";
		}
		else {
			print msg("Unknown cmdline: $_");
		}
	}
	return $ret;
}

# Run a !cmd line
sub runcmd {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $cmd = shift;
	my $txt = shift;
	
	my $exe = "/$CONFIG->{'directory'}/$CONFIG->{'commands'}/$cmd";

	if ( not $cmd =~ /^[^\.]/ or not -x "$exe" ) {
		if ( $CONFIG->{'verbose'} ) {
			$self->privmsg($to, "Error: no such command\n");	
		}
		return;
	}

	runmod($self, $event, $to, $exe, $txt);
	return "ok";
}

# Run a set of hooks
sub runhook {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $hook = shift;
	my $txt = shift;
	
	my $dir = "/$CONFIG->{'directory'}/$CONFIG->{'hooks'}/$hook";
	
	my $ret = "ok";
	if ( -d $dir ) {
		my @hooks;
		opendir(HOOKDIR, $dir);
		while ($_ = readdir(HOOKDIR)) {
			push(@hooks, $_);
		}
		closedir(HOOKDIR);
		foreach $_ (sort @hooks) {
			if (/^[^\.]/ and -x "$dir/$_") {
				my $r = runmod($self, $event, $to, "$dir/$_", $txt);
				if ($r eq "nocmd" or $r eq "noall") {
					$ret = "nocmd";
				}
				if ($r eq "nohook" or $r eq "noall") {
					last;
				}
			}
		}
	}
	return $ret;
}

# A safer replacement for `$cmd` commands
# plus some bangs and wizzing amazingness
sub runmod {
	my $self = shift;
	my $event = shift;
	my $to = shift;
	my $cmd = shift;
	my $txt = shift;
	
	if (not -x "/$cmd") {
		print msg("Error: no such module /$cmd");	
		return "ok";
	}

	local(*FROM_CHILD,*TO_CHILD);
	my $child = open2(*FROM_CHILD,*TO_CHILD,"/$cmd", @{[]}) || die
		msg("run_mod: Cannot fork and run /$cmd");

	

	print TO_CHILD "type $event->{'type'}\n";
	if (defined $event->{'nick'}) {
		print TO_CHILD "nick $event->{'nick'}\n";
	}
	if (defined $event->{'user'}) {
		print TO_CHILD "user $event->{'user'}\n";
	}
	if (defined $event->{'host'}) {
		print TO_CHILD "host $event->{'host'}\n";
	}
	if (defined $to) {
		print TO_CHILD "to $to\n";
	}
	if (defined $txt) {
		print TO_CHILD "msg $txt\n";
	}
	close TO_CHILD;

	my $ret = runaction(*FROM_CHILD,0,$to);

	close FROM_CHILD;
	waitpid($child,0);
	return $ret;
}

# What to do when a connection is recieved from the control socket
sub on_control {

}

# What to do when we receive a private PRIVMSG.
sub on_msg {
	my ($self, $event) = @_;
	my $to = $event->nick;
	my ($msg) = ($event->args);

	my $t = threads->new(sub {
		my $r = runhook($self, $event, $to, "private", $msg);
		if ($r ne "nocmd" and $msg =~ /^!([^\s\/]*)\s*(.*)/) {
    			my $cmd = $1;
			my $txt = $2;

			runcmd($self, $event, $to, $cmd, $txt);
		}
	});
	$t->detach;
}

# What to do when we receive channel text.
sub on_public {
	my ($self, $event) = @_;
	my $to = ${$event->to}[0];
	my ($msg) = ($event->args);

	my $t = threads->new(sub {
		my $r = runhook($self, $event, $to, "public", $msg);
		if ($r ne "nocmd" and $msg =~ /^!([^\s\/]*)\s*(.*)/) {
    			my $cmd = $1;
			my $txt = $2;

			runcmd($self, $event, $to, $cmd, $txt);
		}
	});
	$t->detach;
}


# Change our nick if someone stole it.
sub on_nick_taken {
    my ($self) = shift;

    $self->nick($self->nick . "_");
}

# Exit when connection is lost
sub on_disconnect {
	my ($self, $event) = @_;

	print msg("Disconnected from ", $event->from(), " (",
	      ($event->args())[0], ").");

	exit;	      
}

# Reconnect to the server when we die.
#sub on_disconnect {
#	my ($self, $event) = @_;
#
#	print "hackabot: Disconnected from ", $event->from(), " (",
#	      ($event->args())[0], ").";
#	      
#	sleep(60);
#	print "hackabot: Attempting to reconnect...\n";
#	
#	$self->connect();
#}

#sub extopen {
#	my $conf = shift;
#	
#	my $extfifos = {};
#	my $extdir = $CONFIG->{'directory'}."/".$CONFIG->{'ext'};
#	foreach my $fifo (keys %{$CONFIG->{'extsrc'}}) {
#		my $pipe;
#		sysopen($pipe, "/$extdir/$fifo", O_RDONLY|O_NONBLOCK) or
#			die "hackabot: can't open fifo $!\n";
#		$extfifos->{$fifo} = $pipe;
#	}
#	return $extfifos;
#}
#
#sub extcheck {
#	my $conf = shift;
#	my $extfifos = shift;
#	my $conn = shift;
#
#	foreach my $fifo (keys %$extfifos) {
#		while (my $line = readline($extfifos->{$fifo})) {
#			foreach my $dest (@{$CONFIG->{'extsrc'}->{$fifo}}) {
#				if ($dest->{'type'} eq 'notice') {
#					$conn->notice($dest->{'content'}, "$line\n");
#				}
#				else {
#					$conn->privmsg($dest->{'content'}, "$line\n");
#				}
#			}
#		}
#	}
#}

sub msg {
	my $msg = shift;
	return "hackabot[".threads->self->tid."]: $msg\n";
}

sub blah {
  my ($self, $event) = @_;

  print msg("unhandled event: ".$event->type.": ".
  	join(",",$event->args));
}
#$conn->add_default_handler(\&blah);
#$conn->add_global_handler(353, \&blah);

$conn->add_handler('msg',    \&on_msg);
$conn->add_handler('public', \&on_public);

$conn->add_global_handler('disconnect', \&on_disconnect);
$conn->add_global_handler(376, \&on_connect);
$conn->add_global_handler(433, \&on_nick_taken);


print msg("Starting irc event loop...");
$irc->start;
#my $extfifos = extopen($CONFIG);
#while (1) {
#	$irc->do_one_loop();
#	extcheck($CONFIG, $extfifos, $conn);
#}

